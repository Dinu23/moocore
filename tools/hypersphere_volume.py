import sympy as sp
import mpmath as mpmath
import numpy as np
import re

# Set the precision to 128 bits
mpmath.mp.dps = 128


# Recent versions of mpmpath support this already.
# See https://github.com/mpmath/mpmath/issues/345
def hex(a, prec=128):
    """
    Convert multiprecison float to hexadecimal representation with a defined precision
    """
    a2 = mpmath.mpmathify(a)
    if a2 == mpmath.mpf("0.0"):
        return "0.0"
    if a2 == mpmath.mpf("1.0"):
        return "1.0"
    minus = False
    if a2 < 0:
        a2 = -a2
        minus = True
    e = mpmath.floor(mpmath.log(a2) / mpmath.log(mpmath.mpf("2.0")))
    a2 = a2 * mpmath.power(mpmath.mpf("2.0"), -e) - mpmath.mpf("1.0")
    if minus:
        retstr = "-0x1."
    else:
        retstr = "0x1."
    for l_i in range(prec):
        a2 = a2 * mpmath.mpf("16")
        b = int(a2)
        a2 = a2 - mpmath.mpf(b)
        retstr += "%.1x" % b

    retstr += "p%+.2d" % e
    retstr = re.sub("0+p", "p", retstr)
    return retstr


def hypersphere_area_div_2m(d):
    # Formula: S_{d-1} / 2^d = (2*pi^(d/2) / Gamma(d/2)) / 2^d
    d2 = sp.Rational(d, 2)
    return (2 * (sp.pi**d2) / sp.gamma(d2)) / sp.Pow(2, d)


# Calculate the volume for dimensions d = 2 to 32
values = {0: sp.Float("0.0")}
for d in range(1, 33):
    values[d] = hypersphere_area_div_2m(d)


# Generate C array output
def print_c_array(values, name):
    c_array = f"static const long double {name}" + "[] = {\n"
    for d, v in values.items():
        value = sp.N(v, n=50)
        if value.is_zero:
            value = mpmath.mpf("0.0")
        else:
            value = value.num
        c_array += f"    {hex(value)}L, // d = {d}, value = {np.float128(value)}\n"
    c_array += "};\n"
    print(c_array)


print("""
/* Pre-computed value of S_{d-1} / 2^d = (2*pi^(d/2) / Gamma(d/2)) / 2^d

   Generated by hypersphere_volume.py using long double to preserve as much
   precision as possible.
*/
""")
print_c_array(values, name="sphere_area_div_2_pow_d")

for d in range(1, 33):
    values[d] = values[d] / d

print("""
/* Pre-computed value of S_{d-1} / (d * 2^d) = (2*pi^(d/2) / Gamma(d/2)) / (d * 2^d)

   Generated by hypersphere_volume.py using long double to preserve as much
   precision as possible.
*/
""")
print_c_array(values, name="sphere_area_div_2_pow_d_times_d")
